{"version":3,"file":"cookie-storage.min.js","mappings":"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","sources":["webpack://@mikosoft/cookie-storage/./BrowserCookie.js","webpack://@mikosoft/cookie-storage/./BrowserStorage.js","webpack://@mikosoft/cookie-storage/./index.js"],"sourcesContent":["/**\ninterface CookieOpts {\n  domain?: string;\n  path?: string;\n  expires?: number | Date; // number of hours or exact date\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: string; // 'strict' for GET and POST, 'lax' only for POST\n}\n */\nclass BrowserCookie {\n\n  /**\n   * @param {CookieOpts} cookieOpts - cookie options\n   */\n  constructor(cookieOpts) {\n    if (!cookieOpts) { throw new Error('Cookie options are not defined.'); }\n    if (!document) { throw new Error('The document is not available.'); }\n    this.cookieOpts = cookieOpts;\n  }\n\n\n\n  /**\n   * Set cookie. Cookie value is string.\n   * @param {string} name - cookie name\n   * @param {string} value - cookie value (string)\n   */\n  put(name, value) {\n    if (value === '' || typeof value !== 'string') { throw new Error(`ERR Cookie::put() - The \"${name}\" value must be non-empty string`); }\n\n    // encoding cookie value\n    const valueStr = encodeURIComponent(value); // a b --> a%20b\n\n    // name=value;\n    let cookieStr = `${name}=${valueStr};`;\n\n    // add cookie options: domain, path, expires, secure, HttpOnly, SameSite\n    cookieStr = this._appendCookieOptions(cookieStr);\n    document.cookie = cookieStr;\n  }\n\n\n  /**\n   * Set cookie. Cookie value is object.\n   * @param {string} name - cookie name\n   * @param {object} valueObj - cookie value (object)\n   */\n  putObject(name, valueObj) {\n    if (typeof valueObj !== 'object' || !Object.keys(valueObj).length) { throw new Error(`ERR Cookie::putObject() - The \"${name}\" value must be non-empty object`); }\n\n    // convert object to string and encode that string\n    const valueStr = encodeURIComponent(JSON.stringify(valueObj)); // a b --> a%20b\n\n    // name=value;\n    let cookieStr = `${name}=${valueStr};`;\n\n    // add cookie options: domain, path, expires, secure, HttpOnly, SameSite\n    cookieStr = this._appendCookieOptions(cookieStr);\n    document.cookie = cookieStr;\n  }\n\n\n  /**\n   * Get a cookie by specific name. Returned value is string.\n   * @param {string} name - cookie name\n   * @return {string}\n   */\n  get(name) {\n    const cookiesArr = this._toCookiesArr(); // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n\n    // extract cookie value for specific name\n    let elemArr, cookieVal;\n    cookiesArr.forEach(elem => {\n      elemArr = elem.split('='); // [\"authAPIInit1\", \"jedan1\"]\n      if (elemArr[0] === name) {\n        cookieVal = elemArr[1];\n      }\n    });\n\n    cookieVal = !!cookieVal ? decodeURIComponent(cookieVal) : undefined; // a%20b --> a b\n    return cookieVal;\n  }\n\n\n  /**\n   * Get cookie by specific name. Returned value is object.\n   * @param {string} name - cookie name\n   * @return {object}\n   */\n  getObject(name) {\n    const cookieVal = this.get(name); // %7B%22jen%22%3A1%2C%22dva%22%3A%22dvica%22%7D\n\n    // convert cookie string value to object\n    let obj;\n    try {\n      if (!!cookieVal) { obj = JSON.parse(cookieVal); }\n    } catch (err) {\n      console.error('ERR Cookie::getObject(): Cookie value has invalid JSON and can not be converted to Object. Use get() method instead getObject()');\n    }\n\n    return obj;\n  }\n\n\n  /**\n   *  Get all cookies in array format: [{key1: val1}, {key2: val2},...] . The values (val1, val2, ...) are strings.\n   * @return {object[]}\n   */\n  getAll() {\n    const allCookies_string = document.cookie; // 'cook1=jedan1; cook2=dva2;'\n    const allCookies_arr = allCookies_string.split(';').filter(c => !!c);\n\n    const allCookies_array = allCookies_arr.map(c => {\n      const c_splited = c.split('=');\n\n      let prop = c_splited[0] || '';\n      prop = prop.trim();\n      if (!prop) { return; }\n\n      let val = c_splited[1] || '';\n      val = val.trim();\n      val = !!val ? decodeURIComponent(val) : undefined; // a%20b --> a b\n\n      return { [prop]: val };\n    });\n\n    return allCookies_array;\n  }\n\n\n  /**\n   * Get all cookies in object format: {key1: val1, key2: val2, ...}\n   * @param {boolean} convertType - to convert the value types (val1, val2) or not (default is true)\n   * @return {object}\n   */\n  getObjectAll(convertType = true) {\n    const allCookies_string = document.cookie; // 'cook1=jedan1; cook2=dva2;'\n    const allCookies_arr = allCookies_string.split(';').filter(c => !!c);\n\n    const allCookies_object = {};\n    allCookies_arr.forEach(c => {\n      const c_splited = c.split('=');\n\n      let prop = c_splited[0] || '';\n      prop = prop.trim();\n      if (!prop) { return; }\n\n      let val = c_splited[1] || '';\n      val = val.trim();\n      val = !!val ? decodeURIComponent(val) : undefined; // a%20b --> a b\n      if (convertType) { val = this._stringTypeConvert(val); }\n\n      allCookies_object[prop] = val;\n    });\n\n    return allCookies_object;\n  }\n\n\n  /**\n   * Remove cookie by specific name.\n   * @param {string} name - cookie name\n   */\n  remove(name) {\n    let dateOld = new Date('1970-01-01T01:00:00'); // set expires backward to delete cookie\n    dateOld = dateOld.toUTCString(); // Thu, 01 Jan 1970 00:00:00 GMT\n    document.cookie = `${name}=;expires=${dateOld};path=/;`;\n  }\n\n\n  /**\n   * Remove all cookies.\n   */\n  removeAll() {\n    // set expires backward to delete cookie\n    let dateOld = new Date('1970-01-01T01:00:00'); // set expires backward to delete cookie\n    dateOld = dateOld.toUTCString(); // Thu, 01 Jan 1970 00:00:00 GMT\n\n    // get cookies array\n    const cookiesArr = this._toCookiesArr(); // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n\n    // extract cookie value for specific name\n    let elemArr;\n    const cookiesArr2 = [];\n    cookiesArr.forEach(elem => {\n      elemArr = elem.split('='); // [\"authAPIInit1\", \"jedan1\"]\n      document.cookie = `${elemArr[0]}=;expires=${dateOld};path=/;`;\n      cookiesArr2.push(document.cookie);\n    });\n  }\n\n\n  /**\n   * Check if cookie exists.\n   * @param {string} name - cookie name\n   * @return {boolean}\n   */\n  exists(name) {\n    const cookiesArr = this._toCookiesArr(); // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n\n    // extract cookie value for specific name\n    let elemArr, cookieExists = false;\n    cookiesArr.forEach(elem => {\n      elemArr = elem.split('='); // [\"authAPIInit1\", \"jedan1\"]\n      if (elemArr[0] === name) { cookieExists = true; }\n    });\n\n    return cookieExists;\n  }\n\n\n\n  /******* PRIVATES *******/\n  /**\n   * Add cookie options (domain, path, expires, secure, ...) to the cookie string.\n   * @param {string} cookieStr - cookie string\n   * @return {string}\n   */\n  _appendCookieOptions(cookieStr) {\n    if (!this.cookieOpts) {\n      return cookieStr;\n    }\n\n    // domain=example.com;\n    if (!!this.cookieOpts.domain) {\n      const cDomain = `domain=${this.cookieOpts.domain};`;\n      cookieStr += cDomain;\n    }\n\n    // path=/;\n    if (!!this.cookieOpts.path) {\n      const cPath = `path=${this.cookieOpts.path};`;\n      cookieStr += cPath;\n    }\n\n    // expires=Fri, 3 Aug 2001 20:47:11 UTC;\n    if (!!this.cookieOpts.expires) {\n      let expires;\n      if (typeof this.cookieOpts.expires === 'number') {\n        const d = new Date();\n        d.setTime(d.getTime() + (this.cookieOpts.expires * 60 * 60 * 1000));\n        expires = d.toUTCString();\n      } else {\n        expires = this.cookieOpts.expires.toUTCString();\n      }\n      const cExpires = `expires=${expires};`;\n\n      cookieStr += cExpires;\n    }\n\n    // secure;\n    if (!!this.cookieOpts.secure) {\n      const cSecure = 'secure;';\n      cookieStr += cSecure;\n    }\n\n    // HttpOnly;\n    if (!!this.cookieOpts.httpOnly) {\n      const cHttpOnly = 'HttpOnly;';\n      cookieStr += cHttpOnly;\n    }\n\n    // SameSite=lax; or SameSite=strict;\n    if (!!this.cookieOpts.sameSite) {\n      const cSameSite = `SameSite=${this.cookieOpts.sameSite};`;\n      cookieStr += cSameSite;\n    }\n\n    return cookieStr;\n  }\n\n\n\n  /**\n   * Get all cookies from document.cookie and convert it in the array format.\n   * authAPIInit1=jedan1; authAPIInit2=dva2; authAPI=  --> [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n   * @return {string[]}\n   */\n  _toCookiesArr() {\n    // fetch all cookies\n    const allCookies = document.cookie; // authAPIInit1=jedan1; authAPIInit2=dva2; authAPI=\n\n    // create cookie array\n    const cookiesArr = allCookies.split(';'); // [\"authAPIInit1=jedan1\", \" authAPIInit2=dva2\", \" authAPI=\"]\n\n    // remove empty spaces from left and right side\n    const cookiesArrMapped = cookiesArr.map(cookiesPair => { // cookiesPair: \" authAPIInit2=dva2\"\n      return cookiesPair.trim();\n    });\n\n    return cookiesArrMapped; // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n  }\n\n\n\n  /**\n   * Convert string to correct data type.\n   * @param {string} val\n   * @returns {string | number | boolean | object}\n   */\n  _stringTypeConvert(val) {\n    function isJSON(val) {\n      try { JSON.parse(val); }\n      catch (err) { return false; }\n      return true;\n    }\n\n    if (!!val && !isNaN(val) && !/\\./.test(val)) { // convert string into integer (12)\n      val = parseInt(val, 10);\n    } else if (!!val && !isNaN(val) && /\\./.test(val)) { // convert string into float (12.35)\n      val = parseFloat(val);\n    } else if (val === 'true' || val === 'false') { // convert string into boolean (true)\n      val = JSON.parse(val);\n    } else if (isJSON(val)) {\n      val = JSON.parse(val);\n    }\n\n    return val;\n  }\n\n\n\n}\n\n\nexport default BrowserCookie;\n","/**\ninterface StorageOpts {\n  storageType: 'local'|'session'  // default is local what means localStorage\n}\n */\n\nclass BrowserStorage {\n\n  /**\n   * @param {StorageOpts} storageOpts - {storageType: 'local'|'session'}\n   */\n  constructor(storageOpts) {\n    if (!storageOpts) { throw new Error('Storage options are not defined.'); }\n    if (!window) { throw new Error('The window is not available.'); }\n    this.storageOpts = storageOpts;\n    this.storage = storageOpts.storageType === 'session' ? window.sessionStorage : window.localStorage;\n  }\n\n\n  /**\n   * Set local or session storage.\n   * The input value can be of any type and it's saved as string.\n   * @param {string} name - storage name\n   * @param {any} value - storage value\n   */\n  put(name, value) {\n    if (value === undefined || value === null || value === NaN) { throw new Error(`ERR BrowserStorage::put() - The \"${name}\" value is undefined, null or NaN`); }\n    this.storage.setItem(name, value);\n  }\n\n\n  /**\n   * Set local or session storage.\n   * The input value is object and it's saved as string.\n   * @param {string} name - storage name\n   * @param {object} valueObj - storage value (object)\n   */\n  putObject(name, valueObj) {\n    if (typeof valueObj !== 'object') { throw new Error(`ERR BrowserStorage::putObject() - The \"${name}\" value must be object`); }\n    const value = JSON.stringify(valueObj);\n    this.storage.setItem(name, value);\n  }\n\n\n  /**\n   * Get a storage value (string) by specific name. Returned value is string.\n   * @param {string} name - storage name\n   * @return {string}\n   */\n  get(name) {\n    const value = this.storage.getItem(name) || undefined;\n    return value;\n  }\n\n\n  /**\n   * Get a storage value by specific name. Returned value is object.\n   * @param {string} name - storage name\n   * @return {object}\n   */\n  getObject(name) {\n    const storageVal = this.storage.getItem(name);\n\n    // convert storage string value to object\n    let obj;\n    try {\n      if (!!storageVal) { obj = JSON.parse(storageVal); }\n    } catch (err) {\n      console.error(`ERR BrowserStorage::getObject() [${this.browserStorageOpts.storageType}]: Storage value has invalid JSON and can not be converted to Object. Use get() method instead getObject()`);\n    }\n\n    return obj;\n  }\n\n\n  /**\n   * Get all storage values in array format: [{key1: val1}, {key2: val2},...] . The values (val1, val2, ...) are strings.\n   * @return {object[]}\n   */\n  getAll() {\n    const allStorages_array = [];\n    for (const [key, val] of Object.entries(this.storage)) {\n      allStorages_array.push({ [key]: val });\n    }\n    return allStorages_array;\n  }\n\n\n  /**\n   * Get all storage values in object format: {key1: val1, key2: val2, ...}\n   * @param {boolean} convertType - to convert the value types (val1, val2) or not (default is true)\n   * @return {object}\n   */\n  getObjectAll(convertType = true) {\n    const allStorages_object = {};\n    for (let [prop, val] of Object.entries(this.storage)) {\n      prop = prop.trim();\n      if (!prop) { continue; }\n\n      val = val.trim();\n      if (convertType) { val = this._stringTypeConvert(val); }\n\n      allStorages_object[prop] = val;\n    }\n    return allStorages_object;\n  }\n\n\n  /**\n   * Remove storage by specific name.\n   * @param {string} name - storage name\n   */\n  remove(name) {\n    this.storage.removeItem(name);\n  }\n\n\n  /**\n   * Remove all storage values.\n   */\n  removeAll() {\n    this.storage.clear();\n  }\n\n\n  /**\n   * Check if storage exists.\n   * @param {string} name - storage name\n   * @return {boolean}\n   */\n  exists(name) {\n    const value = this.storage.getItem(name);\n    return !!value;\n  }\n\n\n  /**\n   * Convert string to correct data type.\n   * @param {string} val\n   * @returns {string | number | boolean | object}\n   */\n  _stringTypeConvert(val) {\n    function isJSON(val) {\n      try { JSON.parse(val); }\n      catch (err) { return false; }\n      return true;\n    }\n\n    if (!!val && !isNaN(val) && !/\\./.test(val)) { // convert string into integer (12)\n      val = parseInt(val, 10);\n    } else if (!!val && !isNaN(val) && /\\./.test(val)) { // convert string into float (12.35)\n      val = parseFloat(val);\n    } else if (val === 'true' || val === 'false') { // convert string into boolean (true)\n      val = JSON.parse(val);\n    } else if (isJSON(val)) {\n      val = JSON.parse(val);\n    }\n\n    return val;\n  }\n\n}\n\n\nexport default BrowserStorage;\n","import BrowserCookie from './BrowserCookie.js';\nimport BrowserStorage from './BrowserStorage.js';\n\n// ESM\nexport { BrowserCookie, BrowserStorage };\n\n\n// window\nif (typeof window !== 'undefined') {\n  if (!window.mikosoft) { window.mikosoft = {}; }\n  window.mikosoft.BrowserCookie = BrowserCookie;\n  window.mikosoft.BrowserStorage = BrowserStorage;\n}\n"],"names":["BrowserCookie","cookieOpts","name","value","valueStr","cookieStr","valueObj","cookiesArr","elemArr","cookieVal","elem","obj","c","c_splited","prop","val","convertType","allCookies_arr","allCookies_object","dateOld","cookiesArr2","cookieExists","cDomain","cPath","expires","d","cExpires","cSameSite","cookiesPair","isJSON","BrowserStorage","storageOpts","storageVal","allStorages_array","key","allStorages_object"],"sourceRoot":""}