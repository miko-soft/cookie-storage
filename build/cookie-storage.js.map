{"version":3,"file":"cookie-storage.js","mappings":"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AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA,6BAA6B;AAC7B;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB;AACA;AACA,kEAAkE,oDAAoD,KAAK;AAC3H;AACA;;;AAGA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,wCAAwC,0DAA0D,KAAK;AACvG;AACA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,MAAM;AACN,wDAAwD,oCAAoC;AAC5F;;AAEA;AACA;;;AAGA;AACA,+CAA+C,WAAW,GAAG,WAAW;AACxE,cAAc;AACd;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;;;AAGA;AACA,+CAA+C;AAC/C,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,YAAY;AACZ,oBAAoB;AACpB;AACA;;AAEA,mDAAmD;AACnD;AACA,MAAM,mDAAmD;AACzD;AACA,MAAM,8CAA8C;AACpD;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;;;AAGA,uDAAe,cAAc,EAAC;;;AC/KiB;AACE;;AAEjD;AACyC;;;AAGzC;AACA;AACA;AACA,0BAA0B;AAC1B,uCAAuC,gBAAc;AACrD,sCAAsC,eAAa;AACnD;AACA","sources":["webpack://cookie-storage/./BrowserCookie.js","webpack://cookie-storage/./BrowserStorage.js","webpack://cookie-storage/./index.js"],"sourcesContent":["/**\ninterface CookieOpts {\n  domain?: string;\n  path?: string;\n  expires?: number | Date; // number of hours or exact date\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: string; // 'strict' for GET and POST, 'lax' only for POST\n}\n */\nclass BrowserCookie {\n\n  /**\n   * @param {CookieOpts} cookieOpts - cookie options\n   */\n  constructor(cookieOpts) {\n    if (!document) { throw new Error('The document is not available.'); }\n    this.cookieOpts = cookieOpts;\n  }\n\n\n  /**\n   * CookieOpts {\n   *  domain?: string;\n   *  path?: string;\n   *  expires?: number | Date; // number of hours or exact date\n   *  secure?: boolean;\n   *  httpOnly?: boolean;\n   *  sameSite?: string; // 'strict' for GET and POST, 'lax' only for POST\n   * }\n   * @param {object} cookieOpts - cookie options\n   * @returns {void}\n   */\n  setOptions(cookieOpts = {}) {\n    this.cookieOpts = cookieOpts;\n  }\n\n\n  /**\n   * Set cookie. Cookie value is string.\n   * @param {string} name - cookie name\n   * @param {string} value - cookie value (string)\n   */\n  put(name, value) {\n    if (value === '' || typeof value !== 'string') { throw new Error(`ERR Cookie::put() - The \"${name}\" value must be non-empty string`); }\n\n    // encoding cookie value\n    const valueStr = encodeURIComponent(value); // a b --> a%20b\n\n    // name=value;\n    let cookieStr = `${name}=${valueStr};`;\n\n    // add cookie options: domain, path, expires, secure, HttpOnly, SameSite\n    cookieStr = this._appendCookieOptions(cookieStr);\n    document.cookie = cookieStr;\n  }\n\n\n  /**\n   * Set cookie. Cookie value is object.\n   * @param {string} name - cookie name\n   * @param {object} valueObj - cookie value (object)\n   */\n  putObject(name, valueObj) {\n    if (typeof valueObj !== 'object' || !Object.keys(valueObj).length) { throw new Error(`ERR Cookie::putObject() - The \"${name}\" value must be non-empty object`); }\n\n    // convert object to string and encode that string\n    const valueStr = encodeURIComponent(JSON.stringify(valueObj)); // a b --> a%20b\n\n    // name=value;\n    let cookieStr = `${name}=${valueStr};`;\n\n    // add cookie options: domain, path, expires, secure, HttpOnly, SameSite\n    cookieStr = this._appendCookieOptions(cookieStr);\n    document.cookie = cookieStr;\n  }\n\n\n  /**\n   * Get a cookie by specific name. Returned value is string.\n   * @param {string} name - cookie name\n   * @return {string}\n   */\n  get(name) {\n    const cookiesArr = this._toCookiesArr(); // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n\n    // extract cookie value for specific name\n    let elemArr, cookieVal;\n    cookiesArr.forEach(elem => {\n      elemArr = elem.split('='); // [\"authAPIInit1\", \"jedan1\"]\n      if (elemArr[0] === name) {\n        cookieVal = elemArr[1];\n      }\n    });\n\n    cookieVal = !!cookieVal ? decodeURIComponent(cookieVal) : undefined; // a%20b --> a b\n    return cookieVal;\n  }\n\n\n  /**\n   * Get cookie by specific name. Returned value is object.\n   * @param {string} name - cookie name\n   * @return {object}\n   */\n  getObject(name) {\n    const cookieVal = this.get(name); // %7B%22jen%22%3A1%2C%22dva%22%3A%22dvica%22%7D\n\n    // convert cookie string value to object\n    let obj;\n    try {\n      if (!!cookieVal) { obj = JSON.parse(cookieVal); }\n    } catch (err) {\n      console.error('ERR Cookie::getObject(): Cookie value has invalid JSON and can not be converted to Object. Use get() method instead getObject()');\n    }\n\n    return obj;\n  }\n\n\n  /**\n   *  Get all cookies in array format: [{key1: val1}, {key2: val2},...] . The values (val1, val2, ...) are strings.\n   * @return {object[]}\n   */\n  getAll() {\n    const allCookies_string = document.cookie; // 'cook1=jedan1; cook2=dva2;'\n    const allCookies_arr = allCookies_string.split(';').filter(c => !!c);\n\n    const allCookies_array = allCookies_arr.map(c => {\n      const c_splited = c.split('=');\n\n      let prop = c_splited[0] || '';\n      prop = prop.trim();\n      if (!prop) { return; }\n\n      let val = c_splited[1] || '';\n      val = val.trim();\n      val = !!val ? decodeURIComponent(val) : undefined; // a%20b --> a b\n\n      return { [prop]: val };\n    });\n\n    return allCookies_array;\n  }\n\n\n  /**\n   * Get all cookies in object format: {key1: val1, key2: val2, ...}\n   * @param {boolean} convertType - to convert the value types (val1, val2) or not (default is true)\n   * @return {object}\n   */\n  getObjectAll(convertType = true) {\n    const allCookies_string = document.cookie; // 'cook1=jedan1; cook2=dva2;'\n    const allCookies_arr = allCookies_string.split(';').filter(c => !!c);\n\n    const allCookies_object = {};\n    allCookies_arr.forEach(c => {\n      const c_splited = c.split('=');\n\n      let prop = c_splited[0] || '';\n      prop = prop.trim();\n      if (!prop) { return; }\n\n      let val = c_splited[1] || '';\n      val = val.trim();\n      val = !!val ? decodeURIComponent(val) : undefined; // a%20b --> a b\n      if (convertType) { val = this._stringTypeConvert(val); }\n\n      allCookies_object[prop] = val;\n    });\n\n    return allCookies_object;\n  }\n\n\n  /**\n   * Remove cookie by specific name.\n   * @param {string} name - cookie name\n   */\n  remove(name) {\n    let dateOld = new Date('1970-01-01T01:00:00'); // set expires backward to delete cookie\n    dateOld = dateOld.toUTCString(); // Thu, 01 Jan 1970 00:00:00 GMT\n    document.cookie = `${name}=;expires=${dateOld};path=/;`;\n  }\n\n\n  /**\n   * Remove all cookies.\n   */\n  removeAll() {\n    // set expires backward to delete cookie\n    let dateOld = new Date('1970-01-01T01:00:00'); // set expires backward to delete cookie\n    dateOld = dateOld.toUTCString(); // Thu, 01 Jan 1970 00:00:00 GMT\n\n    // get cookies array\n    const cookiesArr = this._toCookiesArr(); // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n\n    // extract cookie value for specific name\n    let elemArr;\n    const cookiesArr2 = [];\n    cookiesArr.forEach(elem => {\n      elemArr = elem.split('='); // [\"authAPIInit1\", \"jedan1\"]\n      document.cookie = `${elemArr[0]}=;expires=${dateOld};path=/;`;\n      cookiesArr2.push(document.cookie);\n    });\n  }\n\n\n  /**\n   * Check if cookie exists.\n   * @param {string} name - cookie name\n   * @return {boolean}\n   */\n  exists(name) {\n    const cookiesArr = this._toCookiesArr(); // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n\n    // extract cookie value for specific name\n    let elemArr, cookieExists = false;\n    cookiesArr.forEach(elem => {\n      elemArr = elem.split('='); // [\"authAPIInit1\", \"jedan1\"]\n      if (elemArr[0] === name) { cookieExists = true; }\n    });\n\n    return cookieExists;\n  }\n\n\n\n  /******* PRIVATES *******/\n  /**\n   * Add cookie options (domain, path, expires, secure, ...) to the cookie string.\n   * @param {string} cookieStr - cookie string\n   * @return {string}\n   */\n  _appendCookieOptions(cookieStr) {\n    if (!this.cookieOpts) {\n      return cookieStr;\n    }\n\n    // domain=example.com;\n    if (!!this.cookieOpts.domain) {\n      const cDomain = `domain=${this.cookieOpts.domain};`;\n      cookieStr += cDomain;\n    }\n\n    // path=/;\n    if (!!this.cookieOpts.path) {\n      const cPath = `path=${this.cookieOpts.path};`;\n      cookieStr += cPath;\n    }\n\n    // expires=Fri, 3 Aug 2001 20:47:11 UTC;\n    if (!!this.cookieOpts.expires) {\n      let expires;\n      if (typeof this.cookieOpts.expires === 'number') {\n        const d = new Date();\n        d.setTime(d.getTime() + (this.cookieOpts.expires * 60 * 60 * 1000));\n        expires = d.toUTCString();\n      } else {\n        expires = this.cookieOpts.expires.toUTCString();\n      }\n      const cExpires = `expires=${expires};`;\n\n      cookieStr += cExpires;\n    }\n\n    // secure;\n    if (!!this.cookieOpts.secure) {\n      const cSecure = 'secure;';\n      cookieStr += cSecure;\n    }\n\n    // HttpOnly;\n    if (!!this.cookieOpts.httpOnly) {\n      const cHttpOnly = 'HttpOnly;';\n      cookieStr += cHttpOnly;\n    }\n\n    // SameSite=lax; or SameSite=strict;\n    if (!!this.cookieOpts.sameSite) {\n      const cSameSite = `SameSite=${this.cookieOpts.sameSite};`;\n      cookieStr += cSameSite;\n    }\n\n    return cookieStr;\n  }\n\n\n\n  /**\n   * Get all cookies from document.cookie and convert it in the array format.\n   * authAPIInit1=jedan1; authAPIInit2=dva2; authAPI=  --> [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n   * @return {string[]}\n   */\n  _toCookiesArr() {\n    // fetch all cookies\n    const allCookies = document.cookie; // authAPIInit1=jedan1; authAPIInit2=dva2; authAPI=\n\n    // create cookie array\n    const cookiesArr = allCookies.split(';'); // [\"authAPIInit1=jedan1\", \" authAPIInit2=dva2\", \" authAPI=\"]\n\n    // remove empty spaces from left and right side\n    const cookiesArrMapped = cookiesArr.map(cookiesPair => { // cookiesPair: \" authAPIInit2=dva2\"\n      return cookiesPair.trim();\n    });\n\n    return cookiesArrMapped; // [\"authAPIInit1=jedan1\", \"authAPIInit2=dva2\", \"authAPI=\"]\n  }\n\n\n\n  /**\n   * Convert string to correct data type.\n   * @param {string} val\n   * @returns {string | number | boolean | object}\n   */\n  _stringTypeConvert(val) {\n    function isJSON(val) {\n      try { JSON.parse(val); }\n      catch (err) { return false; }\n      return true;\n    }\n\n    if (!!val && !isNaN(val) && !/\\./.test(val)) { // convert string into integer (12)\n      val = parseInt(val, 10);\n    } else if (!!val && !isNaN(val) && /\\./.test(val)) { // convert string into float (12.35)\n      val = parseFloat(val);\n    } else if (val === 'true' || val === 'false') { // convert string into boolean (true)\n      val = JSON.parse(val);\n    } else if (isJSON(val)) {\n      val = JSON.parse(val);\n    }\n\n    return val;\n  }\n\n\n\n}\n\n\nexport default BrowserCookie;\n","/**\ninterface StorageOpts {\n  storageType: 'local'|'session'  // default is local what means localStorage\n}\n */\n\nclass BrowserStorage {\n\n  /**\n   * @param {StorageOpts} storageOpts - {storageType: 'local'|'session'}\n   */\n  constructor(storageOpts) {\n    if (!window) { throw new Error('The window is not available.'); }\n    this.setOptions(storageOpts);\n  }\n\n\n  /**\n   * StorageOpts {\n   *   storageType: 'local'|'session'  // default is local what means localStorage\n   * }\n   * @param {object} storageOpts - cookie options\n   * @returns {void}\n   */\n  setOptions(storageOpts = {}) {\n    this.storageopts = storageOpts;\n    this.storage = storageOpts.storageType === 'session' ? window.sessionStorage : window.localStorage;\n  }\n\n\n  /**\n   * Set local or session storage.\n   * The input value can be of any type and it's saved as string.\n   * @param {string} name - storage name\n   * @param {any} value - storage value\n   */\n  put(name, value) {\n    if (value === undefined || value === null || value === NaN) { throw new Error(`ERR BrowserStorage::put() - The \"${name}\" value is undefined, null or NaN`); }\n    this.storage.setItem(name, value);\n  }\n\n\n  /**\n   * Set local or session storage.\n   * The input value is object and it's saved as string.\n   * @param {string} name - storage name\n   * @param {object} valueObj - storage value (object)\n   */\n  putObject(name, valueObj) {\n    if (typeof valueObj !== 'object') { throw new Error(`ERR BrowserStorage::putObject() - The \"${name}\" value must be object`); }\n    const value = JSON.stringify(valueObj);\n    this.storage.setItem(name, value);\n  }\n\n\n  /**\n   * Get a storage value (string) by specific name. Returned value is string.\n   * @param {string} name - storage name\n   * @return {string}\n   */\n  get(name) {\n    const value = this.storage.getItem(name) || undefined;\n    return value;\n  }\n\n\n  /**\n   * Get a storage value by specific name. Returned value is object.\n   * @param {string} name - storage name\n   * @return {object}\n   */\n  getObject(name) {\n    const storageVal = this.storage.getItem(name);\n\n    // convert storage string value to object\n    let obj;\n    try {\n      if (!!storageVal) { obj = JSON.parse(storageVal); }\n    } catch (err) {\n      console.error(`ERR BrowserStorage::getObject() [${this.browserStorageOpts.storageType}]: Storage value has invalid JSON and can not be converted to Object. Use get() method instead getObject()`);\n    }\n\n    return obj;\n  }\n\n\n  /**\n   * Get all storage values in array format: [{key1: val1}, {key2: val2},...] . The values (val1, val2, ...) are strings.\n   * @return {object[]}\n   */\n  getAll() {\n    const allStorages_array = [];\n    for (const [key, val] of Object.entries(this.storage)) {\n      allStorages_array.push({ [key]: val });\n    }\n    return allStorages_array;\n  }\n\n\n  /**\n   * Get all storage values in object format: {key1: val1, key2: val2, ...}\n   * @param {boolean} convertType - to convert the value types (val1, val2) or not (default is true)\n   * @return {object}\n   */\n  getObjectAll(convertType = true) {\n    const allStorages_object = {};\n    for (let [prop, val] of Object.entries(this.storage)) {\n      prop = prop.trim();\n      if (!prop) { continue; }\n\n      val = val.trim();\n      if (convertType) { val = this._stringTypeConvert(val); }\n\n      allStorages_object[prop] = val;\n    }\n    return allStorages_object;\n  }\n\n\n  /**\n   * Remove storage by specific name.\n   * @param {string} name - storage name\n   */\n  remove(name) {\n    this.storage.removeItem(name);\n  }\n\n\n  /**\n   * Remove all storage values.\n   */\n  removeAll() {\n    this.storage.clear();\n  }\n\n\n  /**\n   * Check if storage exists.\n   * @param {string} name - storage name\n   * @return {boolean}\n   */\n  exists(name) {\n    const value = this.storage.getItem(name);\n    return !!value;\n  }\n\n\n  /**\n   * Convert string to correct data type.\n   * @param {string} val\n   * @returns {string | number | boolean | object}\n   */\n  _stringTypeConvert(val) {\n    function isJSON(val) {\n      try { JSON.parse(val); }\n      catch (err) { return false; }\n      return true;\n    }\n\n    if (!!val && !isNaN(val) && !/\\./.test(val)) { // convert string into integer (12)\n      val = parseInt(val, 10);\n    } else if (!!val && !isNaN(val) && /\\./.test(val)) { // convert string into float (12.35)\n      val = parseFloat(val);\n    } else if (val === 'true' || val === 'false') { // convert string into boolean (true)\n      val = JSON.parse(val);\n    } else if (isJSON(val)) {\n      val = JSON.parse(val);\n    }\n\n    return val;\n  }\n\n}\n\n\nexport default BrowserStorage;\n","import BrowserCookie from './BrowserCookie.js';\nimport BrowserStorage from './BrowserStorage.js';\n\n// ESM\nexport { BrowserCookie, BrowserStorage };\n\n\n// window\nconsole.log(typeof window);\nif (typeof window !== 'undefined') {\n  if (!window.mikosoft) { window.mikosoft = {}; }\n  window.mikosoft.browserStorage = new BrowserStorage();\n  window.mikosoft.browserCookie = new BrowserCookie();\n  console.log('window.mikosoft', window.mikosoft);\n}\n"],"names":[],"sourceRoot":""}